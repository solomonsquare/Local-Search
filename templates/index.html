<!DOCTYPE html>
<html>
<head>
    <title>Location Search</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <style>
        :root {
            --primary-color: #2563eb;
            --primary-hover: #1d4ed8;
            --background-color: #ffffff;
            --surface-color: #f8fafc;
            --border-color: #e2e8f0;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --radius-md: 8px;
            --transition: all 0.2s ease;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: var(--text-primary);
            background-color: var(--background-color);
        }

        #container {
            display: flex;
            height: 100vh;
        }

        #sidebar {
            width: 450px;
            min-width: 450px;
            height: 100%;
            overflow-y: auto;
            background: var(--background-color);
            box-shadow: var(--shadow-md);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
        }

        #search-container {
            padding: 24px;
            border-bottom: 1px solid var(--border-color);
            position: relative;
            background: var(--background-color);
        }

        #export-container {
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-color);
            background: var(--surface-color);
            display: none;
        }

        #export-button {
            width: 100%;
            padding: 12px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: var(--transition);
        }

        #export-button:hover {
            background: var(--primary-hover);
            transform: translateY(-1px);
        }

        #search-input {
            width: 100%;
            padding: 14px 16px;
            font-size: 16px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            box-sizing: border-box;
            margin-bottom: 10px;
            transition: var(--transition);
            background: var(--surface-color);
        }

        #search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        #error-message {
            color: #dc2626;
            display: none;
            margin-top: 12px;
            font-size: 14px;
            padding: 12px;
            background: #fef2f2;
            border-radius: var(--radius-md);
            border: 1px solid #fecaca;
        }

        #results-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 16px;
            background: var(--surface-color);
        }

        .place-item {
            padding: 16px;
            margin-bottom: 12px;
            border-radius: var(--radius-md);
            background: var(--background-color);
            cursor: pointer;
            transition: var(--transition);
            border: 1px solid var(--border-color);
        }

        .place-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            border-color: var(--primary-color);
        }

        .place-name {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .place-type {
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .place-type::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            background: var(--primary-color);
            border-radius: 50%;
        }

        .place-details {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        #map {
            flex-grow: 1;
            height: 100%;
        }

        .suggestions-container {
            position: absolute;
            width: calc(100% - 48px);
            background: var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            margin-top: 4px;
            box-shadow: var(--shadow-md);
            z-index: 1000;
            max-height: 300px;
            overflow-y: auto;
        }

        .suggestion-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: var(--transition);
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover {
            background-color: var(--surface-color);
        }

        .suggestion-main {
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .suggestion-secondary {
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--surface-color);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Loading animation */
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .loading {
            animation: pulse 1.5s ease-in-out infinite;
        }

        /* Map customization */
        .mapboxgl-ctrl-zoom-in,
        .mapboxgl-ctrl-zoom-out {
            background: var(--background-color) !important;
            color: var(--text-primary) !important;
            border: 1px solid var(--border-color) !important;
            border-radius: var(--radius-md) !important;
            margin-bottom: 5px !important;
        }

        .mapboxgl-ctrl-zoom-in:hover,
        .mapboxgl-ctrl-zoom-out:hover {
            background: var(--surface-color) !important;
        }

        .mapboxgl-popup {
            max-width: 300px;
        }

        .mapboxgl-popup-content {
            padding: 15px;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
        }

        /* Quick search icons */
        .quick-search {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: auto auto auto;
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            background: var(--surface-color);
            gap: 20px 12px;
        }

        .category-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            transition: var(--transition);
            padding: 4px;
        }

        .category-icon:hover {
            transform: translateY(-2px);
        }

        .icon-circle {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: var(--background-color);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-sm);
            transition: var(--transition);
        }

        .category-icon:hover .icon-circle {
            box-shadow: var(--shadow-md);
            background: var(--primary-color);
            color: white;
        }

        .icon-circle svg {
            width: 22px;
            height: 22px;
        }

        .category-label {
            font-size: 11px;
            line-height: 1.2;
            font-weight: 500;
            color: var(--text-secondary);
            text-align: center;
            white-space: nowrap;
            margin-top: 2px;
        }

        .category-icon:hover .category-label {
            color: var(--primary-color);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #sidebar {
                width: 100%;
                min-width: 100%;
            }

            .quick-search {
                padding: 16px;
                gap: 16px 10px;
            }
        }

        @media (max-width: 480px) {
            .quick-search {
                grid-template-columns: repeat(3, 1fr);
                padding: 12px;
                gap: 12px 8px;
            }

            .icon-circle {
                width: 40px;
                height: 40px;
            }

            .icon-circle svg {
                width: 20px;
                height: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <div id="search-container">
                <input type="text" id="search-input" placeholder="Search for places (e.g., restaurants in Newcastle)">
                <div id="suggestions" class="suggestions-container" style="display: none;"></div>
                <div id="error-message"></div>
            </div>
            <div class="quick-search">
                <div class="category-icon" onclick="searchCategory('hotel')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"/>
                        </svg>
                    </div>
                    <span class="category-label">Hotels</span>
                </div>
                <div class="category-icon" onclick="searchCategory('restaurant')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h18v18H3zM12 6v12M8 6l8 12M16 6L8 18"/>
                        </svg>
                    </div>
                    <span class="category-label">Food</span>
                </div>
                <div class="category-icon" onclick="searchCategory('mall')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z"/>
                        </svg>
                    </div>
                    <span class="category-label">Shopping</span>
                </div>
                <div class="category-icon" onclick="searchCategory('cafe')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z"/>
                        </svg>
                    </div>
                    <span class="category-label">Coffee</span>
                </div>
                <div class="category-icon" onclick="searchCategory('supermarket')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z"/>
                        </svg>
                    </div>
                    <span class="category-label">Grocery</span>
                </div>
                <div class="category-icon" onclick="searchCategory('fuel')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4h13M3 8h9m-9 4h6m4 0l4-8 4 8M4 16h18M4 20h18"/>
                        </svg>
                    </div>
                    <span class="category-label">Gas</span>
                </div>
                <div class="category-icon" onclick="searchCategory('pub')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4"/>
                        </svg>
                    </div>
                    <span class="category-label">Pub</span>
                </div>
                <div class="category-icon" onclick="searchCategory('night_club')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                        </svg>
                    </div>
                    <span class="category-label">Night Club</span>
                </div>
                <div class="category-icon" onclick="searchCategory('university')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 14l9-5-9-5-9 5 9 5z"/>
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9v6m18-6v6"/>
                        </svg>
                    </div>
                    <span class="category-label">University</span>
                </div>
                <div class="category-icon" onclick="searchCategory('library')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"/>
                        </svg>
                    </div>
                    <span class="category-label">Library</span>
                </div>
                <div class="category-icon" onclick="searchCategory('park')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z"/>
                        </svg>
                    </div>
                    <span class="category-label">Park</span>
                </div>
                <div class="category-icon" onclick="searchCategory('train_station')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                        </svg>
                    </div>
                    <span class="category-label">Train</span>
                </div>
                <div class="category-icon" onclick="searchCategory('bus_station')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7v8a2 2 0 002 2h6M8 7V5a2 2 0 012-2h4a2 2 0 012 2v2M8 7H6a2 2 0 00-2 2v4a2 2 0 002 2h2M16 7h2a2 2 0 012 2v4a2 2 0 01-2 2h-2"/>
                        </svg>
                    </div>
                    <span class="category-label">Bus</span>
                </div>
                <div class="category-icon" onclick="searchCategory('marketplace')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z"/>
                        </svg>
                    </div>
                    <span class="category-label">Market</span>
                </div>
                <div class="category-icon" onclick="searchCategory('playground')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                        </svg>
                    </div>
                    <span class="category-label">Playground</span>
                </div>
                <div class="category-icon" onclick="searchCategory('beach')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z"/>
                        </svg>
                    </div>
                    <span class="category-label">Beach</span>
                </div>
            </div>
            <div id="export-container">
                <button id="export-button" onclick="exportResults()">Export Results</button>
            </div>
            <div id="results-container"></div>
        </div>
        <div id="map"></div>
    </div>

    <script>
        // Initialize Mapbox with the access token from Flask
        mapboxgl.accessToken = '{{ mapbox_token }}';
        
        let map;
        let markers = [];
        let currentBoundary;
        let searchTimeout;

        function initMap() {
            // Initialize the map
            map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/streets-v12',
                center: [-1.6178, 54.9783], // Default center on Newcastle
                zoom: 13
            });

            // Add zoom controls
            map.addControl(new mapboxgl.NavigationControl());

            // Wait for both the map and style to load
            map.on('load', () => {
                setupSearchAutocomplete();
                console.log('Map loaded');
            });
        }

        function clearMarkers() {
            markers.forEach(marker => marker.remove());
            markers = [];
        }

        function addMarker(place) {
            const marker = new mapboxgl.Marker()
                .setLngLat([place.longitude, place.latitude])
                .setPopup(new mapboxgl.Popup().setHTML(`
                    <div class="place-name">${place.name}</div>
                    <div class="place-type">${place.type}</div>
                    <div class="place-details">${place.formatted_address}</div>
                `))
                .addTo(map);
            markers.push(marker);
        }

        function updateMap(places) {
            clearMarkers();
            
            if (places.length > 0) {
                const bounds = new mapboxgl.LngLatBounds();
                
                places.forEach(place => {
                    addMarker(place);
                    bounds.extend([place.longitude, place.latitude]);
                });

                map.fitBounds(bounds, {
                    padding: 50,
                    maxZoom: 15
                });
            }
        }

        function setupSearchAutocomplete() {
            const input = document.getElementById('search-input');
            const suggestionsContainer = document.getElementById('suggestions');

            // Common place types based on Google Places API types
            const placeTypes = [
                { type: 'shopping_mall', keywords: ['shopping mall', 'mall', 'shopping center'] },
                { type: 'supermarket', keywords: ['supermarket', 'grocery store'] },
                { type: 'restaurant', keywords: ['restaurant', 'dining'] },
                { type: 'cafe', keywords: ['cafe', 'coffee shop'] },
                { type: 'bar', keywords: ['bar', 'pub'] },
                { type: 'night_club', keywords: ['night club', 'club'] },
                { type: 'hotel', keywords: ['hotel', 'lodging'] },
                { type: 'school', keywords: ['school'] },
                { type: 'university', keywords: ['university', 'college'] },
                { type: 'hospital', keywords: ['hospital'] },
                { type: 'doctor', keywords: ['doctor', 'physician'] },
                { type: 'pharmacy', keywords: ['pharmacy', 'drugstore'] },
                { type: 'bank', keywords: ['bank'] },
                { type: 'atm', keywords: ['atm', 'cash machine'] },
                { type: 'post_office', keywords: ['post office'] },
                { type: 'police', keywords: ['police station'] },
                { type: 'library', keywords: ['library'] },
                { type: 'park', keywords: ['park', 'garden'] },
                { type: 'gym', keywords: ['gym', 'fitness center'] },
                { type: 'movie_theater', keywords: ['cinema', 'movie theater'] },
                { type: 'gas_station', keywords: ['gas station', 'petrol station'] },
                { type: 'parking', keywords: ['parking', 'car park'] },
                { type: 'train_station', keywords: ['train station', 'railway station'] },
                { type: 'bus_station', keywords: ['bus station', 'bus stop'] },
                { type: 'marketplace', keywords: ['market', 'marketplace', 'farmers market'] },
                { type: 'playground', keywords: ['playground', 'play area'] },
                { type: 'beach', keywords: ['beach', 'seaside'] },
                { type: 'airport', keywords: ['airport'] }
            ];

            input.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                const query = this.value.toLowerCase();
                
                if (query.length < 2) {
                    suggestionsContainer.style.display = 'none';
                    return;
                }

                searchTimeout = setTimeout(async () => {
                    try {
                        let suggestions = [];

                        // Check if query is in "X in Y" format
                        if (query.includes(' in ')) {
                            const [searchTerm, locationTerm] = query.split(/\s+in\s+/);
                            
                            // If location part is empty or very short, suggest place types
                            if (!locationTerm || locationTerm.length < 2) {
                                suggestions = suggestPlaceTypes(searchTerm, placeTypes);
                            } else {
                                // Get location suggestions from Nominatim
                                suggestions = await getLocationSuggestions(locationTerm, searchTerm);
                            }
                        } else {
                            // If query doesn't contain "in", suggest both place types and "in" completion
                            suggestions = suggestPlaceTypes(query, placeTypes);
                            
                            // Add "in" completion suggestions if the query matches any place type
                            if (suggestions.length > 0) {
                                suggestions.push({
                                    display_name: `${query} in...`,
                                    isPlaceType: true,
                                    isInCompletion: true
                                });
                            }
                            
                            // If no place type matches or query is long enough, add location suggestions
                            if (query.length >= 3) {
                                const locationSuggestions = await getLocationSuggestions(query);
                                suggestions = [...suggestions, ...locationSuggestions];
                            }
                        }

                        displaySuggestions(suggestions, query);
                    } catch (error) {
                        console.error('Error fetching suggestions:', error);
                    }
                }, 300);
            });

            // Hide suggestions when clicking outside
            document.addEventListener('click', function(e) {
                if (!input.contains(e.target) && !suggestionsContainer.contains(e.target)) {
                    suggestionsContainer.style.display = 'none';
                }
            });
        }

        function suggestPlaceTypes(query, placeTypes) {
            const suggestions = [];
            
            placeTypes.forEach(({ type, keywords }) => {
                // Check if query matches the type or any of its keywords
                if (type.includes(query) || keywords.some(k => k.includes(query))) {
                    suggestions.push({
                        display_name: type.charAt(0).toUpperCase() + type.slice(1),
                        isPlaceType: true
                    });
                }
            });

            return suggestions;
        }

        async function getLocationSuggestions(locationTerm, searchTerm = '') {
            let searchParams = new URLSearchParams({
                format: 'json',
                addressdetails: 1,
                limit: 5,
                'accept-language': 'en'
            });

            searchParams.append('q', locationTerm);

            const nominatimUrl = `https://nominatim.openstreetmap.org/search?${searchParams.toString()}`;
            const response = await fetch(nominatimUrl);
            let data = await response.json();

            return data;
        }

        function displaySuggestions(suggestions, originalQuery) {
            const container = document.getElementById('suggestions');
            container.innerHTML = '';

            if (suggestions.length === 0) {
                container.style.display = 'none';
                return;
            }

            suggestions.forEach(place => {
                const div = document.createElement('div');
                div.className = 'suggestion-item';

                if (place.isPlaceType) {
                    // Place type suggestion
                    if (place.isInCompletion) {
                        div.innerHTML = `<div class="suggestion-main">${place.display_name}</div>`;
                    } else {
                        div.innerHTML = `<div class="suggestion-main">${place.display_name} in...</div>`;
                    }
                    div.addEventListener('click', () => {
                        const input = document.getElementById('search-input');
                        input.value = place.isInCompletion ? place.display_name : `${place.display_name} in `;
                        input.focus();
                        container.style.display = 'none';
                    });
                } else {
                    // Location suggestion
                    const mainText = place.display_name.split(',')[0];
                    const secondaryText = place.display_name.split(',').slice(1).join(',').trim();
                    
                    div.innerHTML = `
                        <div class="suggestion-main">${mainText}</div>
                        <div class="suggestion-secondary">${secondaryText}</div>
                    `;

                    div.addEventListener('click', () => {
                        const input = document.getElementById('search-input');
                        const searchPrefix = originalQuery.includes(' in ') ? 
                            originalQuery.split(' in ')[0] + ' in ' : '';
                        input.value = searchPrefix + place.display_name;
                        container.style.display = 'none';
                        searchLocation(place);
                    });
                }

                container.appendChild(div);
            });

            container.style.display = 'block';
        }

        function showError(message) {
            // Clear any existing results first
            const resultsContainer = document.getElementById('results-container');
            const exportContainer = document.getElementById('export-container');
            resultsContainer.innerHTML = '';
            exportContainer.style.display = 'none';

            // Show error message
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function updateResultsList(places) {
            const container = document.getElementById('results-container');
            const exportContainer = document.getElementById('export-container');
            container.innerHTML = '';

            if (places.length > 0) {
                exportContainer.style.display = 'block';
            } else {
                exportContainer.style.display = 'none';
            }

            places.forEach(place => {
                const div = document.createElement('div');
                div.className = 'place-item';
                
                let type = 'Place';
                if (place.tags.amenity) type = place.tags.amenity.replace(/_/g, ' ');
                if (place.tags.tourism) type = place.tags.tourism.replace(/_/g, ' ');
                if (place.tags.shop) type = place.tags.shop.replace(/_/g, ' ');
                type = type.charAt(0).toUpperCase() + type.slice(1);

                div.innerHTML = `
                    <div class="place-name">${place.tags.name || `Unnamed ${type}`}</div>
                    <div class="place-type">${type}</div>
                    <div class="place-details">
                        ${place.tags.cuisine ? `<div>Cuisine: ${place.tags.cuisine}</div>` : ''}
                        ${place.tags.opening_hours ? `<div>Hours: ${place.tags.opening_hours}</div>` : ''}
                        ${place.tags.phone ? `<div>Phone: ${place.tags.phone}</div>` : ''}
                        ${place.tags.addr_street ? `<div>Address: ${place.tags.addr_street}${place.tags.addr_housenumber ? ' ' + place.tags.addr_housenumber : ''}</div>` : ''}
                    </div>
                `;

                div.addEventListener('click', () => {
                    const position = place.type === 'node' ? 
                        [place.lon, place.lat] : // Mapbox uses [longitude, latitude]
                        [place.center.lon, place.center.lat];
                    
                    map.flyTo({
                        center: position,
                        zoom: 18
                    });

                    const marker = markers.find(m => {
                        const markerPos = m.getLngLat();
                        return markerPos.lng === position[0] && markerPos.lat === position[1];
                    });
                    if (marker) {
                        marker.togglePopup();
                    }
                });

                container.appendChild(div);
            });
        }

        function getBoundingBoxAndCenter(location) {
            if (!location) return [null, null];

            let boundingBox;
            const center = {
                lat: parseFloat(location.lat),
                lon: parseFloat(location.lon)
            };

            // Use more precise boundaries for cities and towns
            if (location.type === 'city' || location.type === 'town' || 
                location.type === 'administrative' || location.osm_type === 'relation' ||
                location.class === 'boundary' || location.class === 'place') {
                
                const bbox = location.boundingbox.map(parseFloat);
                boundingBox = [[bbox[2], bbox[0]], [bbox[3], bbox[1]]]; // Convert to [lng, lat] format for Mapbox
            } else {
                // For other locations, use a reasonable radius
                const radius = 0.05; // roughly 5km
                boundingBox = [
                    [center.lon - radius, center.lat - radius],
                    [center.lon + radius, center.lat + radius]
                ];
            }

            return [boundingBox, center];
        }

        function addMarkers(places) {
            clearMarkers();
            
            // Get the boundary coordinates from the current boundary source
            let boundaryCoords;
            if (map.getSource('boundary')) {
                const boundaryData = map.getSource('boundary')._data;
                if (boundaryData.geometry && boundaryData.geometry.coordinates) {
                    boundaryCoords = boundaryData.geometry.coordinates[0];
                }
            }

            // Filter and add markers
            const validPlaces = places.filter(place => {
                if (!(place.type === 'node' || (place.type === 'way' && place.center)) || !place.tags) {
                    return false;
                }

                const position = place.type === 'node' ? 
                    [place.lon, place.lat] : // Mapbox uses [longitude, latitude]
                    [place.center.lon, place.center.lat];

                // Skip if no valid coordinates
                if (!position || position.some(isNaN)) {
                    return false;
                }

                // Check if point is inside boundary
                if (boundaryCoords) {
                    let inside = false;
                    for (let i = 0, j = boundaryCoords.length - 1; i < boundaryCoords.length; j = i++) {
                        const [xi, yi] = boundaryCoords[i];
                        const [xj, yj] = boundaryCoords[j];
                        
                        const intersect = ((yi > position[1]) !== (yj > position[1])) &&
                            (position[0] < (xj - xi) * (position[1] - yi) / (yj - yi) + xi);
                        
                        if (intersect) inside = !inside;
                    }
                    return inside;
                }
                return true;
            });

            // First update the results list with only valid places
            updateResultsList(validPlaces);
            
            // Then add markers for valid places
            validPlaces.forEach(place => {
                const position = place.type === 'node' ? 
                    [place.lon, place.lat] : 
                    [place.center.lon, place.center.lat];

                let type = 'Place';
                if (place.tags.amenity) type = place.tags.amenity.replace(/_/g, ' ');
                if (place.tags.tourism) type = place.tags.tourism.replace(/_/g, ' ');
                if (place.tags.shop) type = place.tags.shop.replace(/_/g, ' ');
                type = type.charAt(0).toUpperCase() + type.slice(1);

                const marker = new mapboxgl.Marker()
                    .setLngLat(position)
                    .setPopup(new mapboxgl.Popup().setHTML(`
                        <strong>${place.tags.name || `Unnamed ${type}`}</strong><br>
                        <em>${type}</em><br>
                        ${place.tags.cuisine ? `Cuisine: ${place.tags.cuisine}<br>` : ''}
                        ${place.tags.opening_hours ? `Hours: ${place.tags.opening_hours}<br>` : ''}
                        ${place.tags.phone ? `Phone: ${place.tags.phone}<br>` : ''}
                        ${place.tags.website ? `<a href="${place.tags.website}" target="_blank">Website</a><br>` : ''}
                        ${place.tags.addr_street ? `Address: ${place.tags.addr_street}${place.tags.addr_housenumber ? ' ' + place.tags.addr_housenumber : ''}<br>` : ''}
                    `))
                    .addTo(map);
                markers.push(marker);
            });

            // Show/hide export button based on results
            const exportContainer = document.getElementById('export-container');
            exportContainer.style.display = validPlaces.length > 0 ? 'block' : 'none';
        }

        function searchLocation(selectedPlace = null) {
            try {
                let searchQuery = document.getElementById('search-input').value;
                
                if (!searchQuery && !selectedPlace) {
                    showError('Please enter a search query');
                    return;
                }

                // Clear everything at the start of a new search
                clearAllResults();

                // Parse search query
                let searchTerm = '';
                let locationTerm = '';
                
                if (selectedPlace) {
                    locationTerm = selectedPlace.display_name;
                } else if (searchQuery.toLowerCase().includes(' in ')) {
                    const parts = searchQuery.split(/\s+in\s+/i);
                    searchTerm = parts[0].trim();
                    locationTerm = parts[1].trim();
                } else {
                    locationTerm = searchQuery.trim();
                }

                getLocation(locationTerm).then(location => {
                    if (!location) {
                        showError('Location not found. Please try a different location.');
                        return;
                    }

                    const [boundingBox, center] = getBoundingBoxAndCenter(location);
                    currentBoundary = boundingBox;

                    // Create a proper GeoJSON feature
                    const geojsonData = {
                        type: 'Feature',
                        properties: {},
                        geometry: location.geojson || {
                            type: 'Polygon',
                            coordinates: [[
                                [boundingBox[0][0], boundingBox[0][1]],
                                [boundingBox[1][0], boundingBox[0][1]],
                                [boundingBox[1][0], boundingBox[1][1]],
                                [boundingBox[0][0], boundingBox[1][1]],
                                [boundingBox[0][0], boundingBox[0][1]]
                            ]]
                        }
                    };

                    // Add the boundary to the map and then search for places
                    const addBoundaryAndSearch = async () => {
                        try {
                            await addBoundaryToMap(geojsonData, location);
                            
                            // Only search for places if a specific type was requested
                            if (searchTerm) {
                                const places = await searchPlaces(searchTerm, center, boundingBox, location.areaId);
                                if (places.length === 0) {
                                    showError('No places found in this area. Try a different search.');
                                    return;
                                }
                                addMarkers(places);
                            }
                        } catch (error) {
                            console.error('Error in boundary addition or search:', error);
                            showError('Failed to complete the search. Please try again.');
                        }
                    };

                    // Hide error message if it was showing
                    const errorDiv = document.getElementById('error-message');
                    errorDiv.style.display = 'none';

                    if (!map.isStyleLoaded()) {
                        map.once('style.load', addBoundaryAndSearch);
                    } else {
                        addBoundaryAndSearch();
                    }
                }).catch(error => {
                    console.error('Location search error:', error);
                    showError('Failed to find location. Please try again.');
                });
            } catch (error) {
                console.error('Search error:', error);
                showError('Failed to perform search. Please try again.');
            }
        }

        async function getLocation(locationTerm) {
            try {
                // Get location data from Nominatim
                const nominatimUrl = `https://nominatim.openstreetmap.org/search?` + 
                    `format=json&` +
                    `q=${encodeURIComponent(locationTerm)}&` +
                    `polygon_geojson=1&` +
                    `addressdetails=1&` +
                    `limit=10`;

                const response = await fetch(nominatimUrl);
                const data = await response.json();

                if (data.length > 0) {
                    // First try to find a location with valid polygon data
                    let location = data.find(loc => {
                        const hasValidPolygon = loc.geojson?.type === 'Polygon' &&
                            Array.isArray(loc.geojson?.coordinates) &&
                            loc.geojson.coordinates.length > 0;

                        const isRelevantType = (
                            loc.class === 'boundary' ||
                            loc.type === 'suburb' ||
                            loc.type === 'neighbourhood' ||
                            loc.type === 'residential' ||
                            loc.type === 'administrative' ||
                            loc.class === 'place' ||
                            loc.osm_type === 'relation'
                        );

                        return hasValidPolygon && isRelevantType;
                    });

                    // If no location with polygon found, take the first result
                    if (!location) {
                        location = data[0];
                    }

                    console.log('Selected location:', location);

                    // If we have a valid polygon from Nominatim, use it
                    if (location.geojson?.type === 'Polygon' &&
                        Array.isArray(location.geojson?.coordinates) &&
                        location.geojson.coordinates.length > 0) {
                        
                        console.log('Using polygon from Nominatim:', location.geojson);
                        return location;
                    }

                    // If no polygon, try to get boundary from Overpass API
                    if (location.osm_type && location.osm_id) {
                        try {
                            // First try to get the relation for the area
                            let overpassQuery = `[out:json][timeout:25];
                                area[name="${location.name}"][admin_level][boundary=administrative];
                                out geom;`;

                            let overpassResponse = await fetch('https://overpass-api.de/api/interpreter', {
                                method: 'POST',
                                body: `data=${encodeURIComponent(overpassQuery)}`
                            });

                            if (overpassResponse.ok) {
                                const osmData = await overpassResponse.json();
                                if (osmData.elements && osmData.elements.length > 0) {
                                    const element = osmData.elements[0];
                                    if (element.geometry) {
                                        location.geojson = {
                                            type: 'Polygon',
                                            coordinates: [element.geometry.map(point => [point.lon, point.lat])]
                                        };
                                        return location;
                                    }
                                }
                            }

                            // If no administrative boundary found, try direct object geometry
                            overpassQuery = `[out:json][timeout:25];
                                ${location.osm_type}(${location.osm_id});
                                out geom;`;

                            overpassResponse = await fetch('https://overpass-api.de/api/interpreter', {
                                method: 'POST',
                                body: `data=${encodeURIComponent(overpassQuery)}`
                            });

                            if (overpassResponse.ok) {
                                const osmData = await overpassResponse.json();
                                if (osmData.elements && osmData.elements.length > 0) {
                                    const element = osmData.elements[0];
                                    if (element.geometry) {
                                        location.geojson = {
                                            type: 'Polygon',
                                            coordinates: [element.geometry.map(point => [point.lon, point.lat])]
                                        };
                                        return location;
                                    }
                                }
                            }
                        } catch (error) {
                            console.error('Error fetching from Overpass:', error);
                        }
                    }

                    // If we still have a location but no polygon, return it anyway
                    // The boundary will be handled by the bounding box
                    return location;
                }

                console.error('No valid location found');
                return null;
            } catch (error) {
                console.error('Error fetching location:', error);
                return null;
            }
        }

        function getAmenityFilter(searchTerm) {
            if (!searchTerm) return '["shop"~"mall|department_store"]';
            
            const term = searchTerm.toLowerCase();
            
            // Exact matching for specific place types
            if (term.includes('shopping mall') || term.includes('mall')) {
                return '["shop"~"mall|department_store"]';
            }
            if (term.includes('supermarket')) {
                return '["shop"="supermarket"]';
            }
            if (term.includes('restaurant')) {
                return '["amenity"="restaurant"]';
            }
            if (term.includes('cafe')) {
                return '["amenity"="cafe"]';
            }
            if (term.includes('bar') || term.includes('pub')) {
                return '["amenity"~"^(bar|pub)$"]';
            }
            if (term.includes('hotel')) {
                return '["tourism"="hotel"]';
            }
            if (term.includes('night') || term.includes('club') || term.includes('nightclub')) {
                return '["amenity"="nightclub"]';
            }
            if (term.includes('school')) {
                return '["amenity"="school"]';
            }
            if (term.includes('university')) {
                return '["amenity"="university"]';
            }
            if (term.includes('hospital')) {
                return '["amenity"="hospital"]';
            }
            if (term.includes('pharmacy')) {
                return '["amenity"="pharmacy"]';
            }
            if (term.includes('bank')) {
                return '["amenity"="bank"]';
            }
            if (term.includes('post office')) {
                return '["amenity"="post_office"]';
            }
            if (term.includes('police')) {
                return '["amenity"="police"]';
            }
            if (term.includes('library')) {
                return '["amenity"="library"]';
            }
            if (term.includes('park') && !term.includes('skate')) {
                return '["leisure"="park"]';
            }
            if (term.includes('playground')) {
                return '["leisure"="playground"]';
            }
            if (term.includes('beach')) {
                return '["natural"="beach"]';
            }
            if (term.includes('market')) {
                return '["amenity"="marketplace"]|["shop"="marketplace"]';
            }
            if (term.includes('train station')) {
                return '["railway"="station"]';
            }
            if (term.includes('bus station') || term.includes('bus stop')) {
                return '["highway"="bus_stop"]|["amenity"="bus_station"]';
            }
            if (term.includes('airport')) {
                return '["aeroway"="aerodrome"]';
            }

            // If no exact match, try to match the term exactly against tags
            const cleanTerm = term.replace(/s\b/g, '').replace(/\s+/g, '_');
            return `["amenity"="${cleanTerm}"]|["shop"="${cleanTerm}"]|["tourism"="${cleanTerm}"]|["leisure"="${cleanTerm}"]`;
        }

        async function searchPlaces(searchTerm, center, boundingBox, areaId) {
            let amenityFilter = getAmenityFilter(searchTerm);
            
            // Ensure we have valid coordinates for the bounding box
            const south = Math.min(boundingBox[0][1], boundingBox[1][1]);
            const west = Math.min(boundingBox[0][0], boundingBox[1][0]);
            const north = Math.max(boundingBox[0][1], boundingBox[1][1]);
            const east = Math.max(boundingBox[0][0], boundingBox[1][0]);
            
            // Create a search query that works for any area
            const query = `[out:json][timeout:30];
                (
                    way${amenityFilter}(${south},${west},${north},${east});
                    node${amenityFilter}(${south},${west},${north},${east});
                );
                out body center qt;
                >;
                out skel qt;`;

            try {
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: `data=${encodeURIComponent(query)}`
                });
                
                if (!response.ok) {
                    throw new Error('Failed to fetch from Overpass API');
                }

                const data = await response.json();
                
                // Sort results by distance from center
                return data.elements
                    .filter(element => element.tags)
                    .sort((a, b) => {
                        const aLat = a.type === 'node' ? a.lat : a.center.lat;
                        const aLon = a.type === 'node' ? a.lon : a.center.lon;
                        const bLat = b.type === 'node' ? b.lat : b.center.lat;
                        const bLon = b.type === 'node' ? b.lon : b.center.lon;
                        
                        const distA = Math.sqrt(
                            Math.pow(aLat - center.lat, 2) + 
                            Math.pow(aLon - center.lon, 2)
                        );
                        const distB = Math.sqrt(
                            Math.pow(bLat - center.lat, 2) + 
                            Math.pow(bLon - center.lon, 2)
                        );
                        
                        return distA - distB;
                    });
            } catch (error) {
                console.error('Overpass API error:', error);
                throw new Error('Failed to fetch places. Please try again.');
            }
        }

        function exportResults() {
            const container = document.getElementById('results-container');
            const places = Array.from(container.getElementsByClassName('place-item')).map(item => {
                const name = item.querySelector('.place-name').textContent;
                const type = item.querySelector('.place-type').textContent;
                const details = Array.from(item.querySelector('.place-details').children)
                    .map(div => div.textContent)
                    .join('\n');
                return `${name}\n${type}\n${details}\n-------------------`;
            }).join('\n\n');

            const blob = new Blob([places], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'search_results.txt';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        async function searchCategory(category) {
            const input = document.getElementById('search-input');
            const currentLocation = input.value.split(' in ')[1];
            
            if (!currentLocation && !currentBoundary) {
                showError('Please enter a location first');
                return;
            }

            // Clear error message at the start of new search
            clearError();

            try {
                // If we have a current boundary, search within it
                if (currentBoundary) {
                    const bounds = new mapboxgl.LngLatBounds(currentBoundary[0], currentBoundary[1]);
                    const center = bounds.getCenter();
                    
                    // Adjust category for gas stations
                    const searchTerm = category === 'fuel' ? 'petrol_station' : category;
                    
                    const places = await searchPlaces(searchTerm, 
                        { lat: center.lat, lon: center.lng }, 
                        currentBoundary, currentBoundary.areaId);
                    
                    if (places.length === 0) {
                        showError(`No ${category.replace('_', ' ')} found in this area`);
                        return;
                    }

                    addMarkers(places);
                } else {
                    // If no boundary, perform a new search with the category
                    input.value = `${category} in ${currentLocation}`;
                    searchLocation();
                }
            } catch (error) {
                console.error('Category search error:', error);
                showError('Failed to search for places. Please try again.');
            }
        }

        // Add a separate function to clear error message
        function clearError() {
            const errorDiv = document.getElementById('error-message');
            errorDiv.style.display = 'none';
            errorDiv.textContent = '';
        }

        function clearAllResults() {
            // Clear results list and hide export button
            const resultsContainer = document.getElementById('results-container');
            const exportContainer = document.getElementById('export-container');
            resultsContainer.innerHTML = '';
            exportContainer.style.display = 'none';

            // Clear existing markers
            clearMarkers();

            // Clear boundary
            if (map.getSource('boundary')) {
                map.removeLayer('boundary-line');
                map.removeLayer('boundary-fill');
                map.removeSource('boundary');
            }

            // Clear error message
            const errorDiv = document.getElementById('error-message');
            errorDiv.style.display = 'none';
            errorDiv.textContent = '';
        }

        function createPolygonFromPoint(longitude, latitude, radiusInKm = 1) {
            const points = 32; // Number of points to create the circle
            const coords = [];
            const kmInLongitudeDegree = 111.320 * Math.cos(latitude * Math.PI / 180);
            
            // Convert km to degrees for lat/lon
            const radiusLat = radiusInKm / 111.0;
            const radiusLon = radiusInKm / kmInLongitudeDegree;

            for (let i = 0; i < points; i++) {
                const angle = (i * 360 / points) * Math.PI / 180;
                const x = longitude + radiusLon * Math.cos(angle);
                const y = latitude + radiusLat * Math.sin(angle);
                coords.push([x, y]);
            }
            
            // Close the polygon by repeating the first point
            coords.push(coords[0]);
            
            return {
                type: 'Polygon',
                coordinates: [coords]
            };
        }

        function addBoundaryToMap(geojsonData, location) {
            return new Promise((resolve, reject) => {
                try {
                    const addBoundaryLayers = () => {
                        try {
                            // Remove existing boundary if it exists
                            if (map.getSource('boundary')) {
                                if (map.getLayer('boundary-line')) map.removeLayer('boundary-line');
                                if (map.getLayer('boundary-fill')) map.removeLayer('boundary-fill');
                                map.removeSource('boundary');
                            }

                            let featureCollection;
                            
                            // First try to use the provided geojson if it's a valid polygon
                            if (location.geojson?.type === 'Polygon' && 
                                Array.isArray(location.geojson?.coordinates) && 
                                location.geojson.coordinates.length > 0) {
                                featureCollection = {
                                    type: 'Feature',
                                    geometry: location.geojson,
                                    properties: {}
                                };
                            }
                            // If no valid polygon, check if it's a point-based location
                            else if (location.osm_type === 'node' && location.lat && location.lon) {
                                const lat = parseFloat(location.lat);
                                const lon = parseFloat(location.lon);
                                featureCollection = {
                                    type: 'Feature',
                                    geometry: createPolygonFromPoint(lon, lat, 2),
                                    properties: {}
                                };
                            }
                            // Fallback to bounding box if provided
                            else if (geojsonData?.geometry) {
                                featureCollection = geojsonData;
                            }
                            // If all else fails, create a small bounding box around the point
                            else if (location.lat && location.lon) {
                                const lat = parseFloat(location.lat);
                                const lon = parseFloat(location.lon);
                                const radius = 0.02; // roughly 2km
                                featureCollection = {
                                    type: 'Feature',
                                    geometry: {
                                        type: 'Polygon',
                                        coordinates: [[
                                            [lon - radius, lat - radius],
                                            [lon + radius, lat - radius],
                                            [lon + radius, lat + radius],
                                            [lon - radius, lat + radius],
                                            [lon - radius, lat - radius]
                                        ]]
                                    },
                                    properties: {}
                                };
                            }

                            if (!featureCollection) {
                                throw new Error('Unable to create boundary for this location');
                            }

                            // Add the boundary source
                            map.addSource('boundary', {
                                'type': 'geojson',
                                'data': featureCollection
                            });

                            // Add fill layer
                            map.addLayer({
                                'id': 'boundary-fill',
                                'type': 'fill',
                                'source': 'boundary',
                                'paint': {
                                    'fill-color': '#E14C48',
                                    'fill-opacity': 0.15
                                }
                            });

                            // Add line layer
                            map.addLayer({
                                'id': 'boundary-line',
                                'type': 'line',
                                'source': 'boundary',
                                'paint': {
                                    'line-color': '#000000',
                                    'line-width': 3
                                }
                            });

                            // Calculate bounds
                            const bounds = new mapboxgl.LngLatBounds();
                            featureCollection.geometry.coordinates[0].forEach(coord => {
                                bounds.extend(coord);
                            });

                            // Fit the map to the bounds
                            map.fitBounds(bounds, {
                                padding: 50,
                                maxZoom: 15,
                                duration: 2000
                            });

                            // Store the boundary for later use
                            currentBoundary = [
                                [bounds.getWest(), bounds.getSouth()],
                                [bounds.getEast(), bounds.getNorth()]
                            ];
                            currentBoundary.areaId = location.osm_id;

                            resolve();
                        } catch (error) {
                            console.error('Error adding boundary layers:', error);
                            reject(error);
                        }
                    };

                    if (!map.isStyleLoaded()) {
                        map.once('style.load', addBoundaryLayers);
                    } else {
                        addBoundaryLayers();
                    }
                } catch (error) {
                    console.error('Error in addBoundaryToMap:', error);
                    reject(error);
                }
            });
        }

        // Initialize the map when the page loads
        document.addEventListener('DOMContentLoaded', initMap);

        // Add enter key support for search
        document.getElementById('search-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchLocation();
            }
        });
    </script>
</body>
</html> 