<!DOCTYPE html>
<html>
<head>
    <title>Location Search</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #2563eb;
            --primary-hover: #1d4ed8;
            --background-color: #ffffff;
            --surface-color: #f8fafc;
            --border-color: #e2e8f0;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --radius-md: 8px;
            --transition: all 0.2s ease;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: var(--text-primary);
            background-color: var(--background-color);
        }

        #container {
            display: flex;
            height: 100vh;
        }

        #sidebar {
            width: 380px;
            min-width: 380px;
            height: 100%;
            overflow-y: auto;
            background: var(--background-color);
            box-shadow: var(--shadow-md);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
        }

        #search-container {
            padding: 24px;
            border-bottom: 1px solid var(--border-color);
            position: relative;
            background: var(--background-color);
        }

        #export-container {
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-color);
            background: var(--surface-color);
            display: none;
        }

        #export-button {
            width: 100%;
            padding: 12px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: var(--transition);
        }

        #export-button:hover {
            background: var(--primary-hover);
            transform: translateY(-1px);
        }

        #search-input {
            width: 100%;
            padding: 14px 16px;
            font-size: 16px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            box-sizing: border-box;
            margin-bottom: 10px;
            transition: var(--transition);
            background: var(--surface-color);
        }

        #search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        #error-message {
            color: #dc2626;
            display: none;
            margin-top: 12px;
            font-size: 14px;
            padding: 12px;
            background: #fef2f2;
            border-radius: var(--radius-md);
            border: 1px solid #fecaca;
        }

        #results-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 16px;
            background: var(--surface-color);
        }

        .place-item {
            padding: 16px;
            margin-bottom: 12px;
            border-radius: var(--radius-md);
            background: var(--background-color);
            cursor: pointer;
            transition: var(--transition);
            border: 1px solid var(--border-color);
        }

        .place-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            border-color: var(--primary-color);
        }

        .place-name {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .place-type {
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .place-type::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            background: var(--primary-color);
            border-radius: 50%;
        }

        .place-details {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        #map {
            flex-grow: 1;
            height: 100%;
        }

        .suggestions-container {
            position: absolute;
            width: calc(100% - 48px);
            background: var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            margin-top: 4px;
            box-shadow: var(--shadow-md);
            z-index: 1000;
            max-height: 300px;
            overflow-y: auto;
        }

        .suggestion-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: var(--transition);
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover {
            background-color: var(--surface-color);
        }

        .suggestion-main {
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .suggestion-secondary {
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--surface-color);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Loading animation */
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .loading {
            animation: pulse 1.5s ease-in-out infinite;
        }

        /* Map customization */
        .leaflet-control-zoom {
            border: none !important;
            box-shadow: var(--shadow-md) !important;
        }

        .leaflet-control-zoom a {
            background: var(--background-color) !important;
            color: var(--text-primary) !important;
            border: 1px solid var(--border-color) !important;
        }

        .leaflet-control-zoom a:hover {
            background: var(--surface-color) !important;
        }

        /* Quick search icons */
        .quick-search {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            background: var(--surface-color);
            gap: 8px;
        }

        .category-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            transition: var(--transition);
            padding: 4px;
        }

        .category-icon:hover {
            transform: translateY(-2px);
        }

        .icon-circle {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--background-color);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-sm);
            transition: var(--transition);
        }

        .category-icon:hover .icon-circle {
            box-shadow: var(--shadow-md);
            background: var(--primary-color);
            color: white;
        }

        .icon-circle svg {
            width: 20px;
            height: 20px;
        }

        .category-label {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
            text-align: center;
            white-space: nowrap;
        }

        .category-icon:hover .category-label {
            color: var(--primary-color);
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            .quick-search {
                grid-template-columns: repeat(3, 1fr);
                padding: 8px;
            }

            .icon-circle {
                width: 36px;
                height: 36px;
            }

            .icon-circle svg {
                width: 18px;
                height: 18px;
            }

            .category-label {
                font-size: 10px;
            }
        }
    </style>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <div id="search-container">
                <input type="text" id="search-input" placeholder="Search for places (e.g., restaurants in Newcastle)">
                <div id="suggestions" class="suggestions-container" style="display: none;"></div>
                <div id="error-message"></div>
            </div>
            <div class="quick-search">
                <div class="category-icon" onclick="searchCategory('hotel')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"/>
                        </svg>
                    </div>
                    <span class="category-label">Hotels</span>
                </div>
                <div class="category-icon" onclick="searchCategory('restaurant')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h18v18H3zM12 6v12M8 6l8 12M16 6L8 18"/>
                        </svg>
                    </div>
                    <span class="category-label">Food</span>
                </div>
                <div class="category-icon" onclick="searchCategory('mall')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z"/>
                        </svg>
                    </div>
                    <span class="category-label">Shopping</span>
                </div>
                <div class="category-icon" onclick="searchCategory('cafe')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z"/>
                        </svg>
                    </div>
                    <span class="category-label">Coffee</span>
                </div>
                <div class="category-icon" onclick="searchCategory('supermarket')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z"/>
                        </svg>
                    </div>
                    <span class="category-label">Grocery</span>
                </div>
                <div class="category-icon" onclick="searchCategory('fuel')">
                    <div class="icon-circle">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4h13M3 8h9m-9 4h6m4 0l4-8 4 8M4 16h18M4 20h18"/>
                        </svg>
                    </div>
                    <span class="category-label">Gas</span>
                </div>
            </div>
            <div id="export-container">
                <button id="export-button" onclick="exportResults()">Export Results</button>
            </div>
            <div id="results-container"></div>
        </div>
        <div id="map"></div>
    </div>

    <script>
        let map;
        let markers = [];
        let currentBoundary;
        let searchTimeout;

        function initMap() {
            map = L.map('map', {
                maxBounds: [[-90, -180], [90, 180]],
                maxBoundsViscosity: 1.0,
                wheelDebounceTime: 100,
                zoomControl: true
            }).setView([54.9783, -1.6178], 13);  // Default center on Newcastle
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                minZoom: 11,
                attribution: '&copy; OpenStreetMap contributors'
            }).addTo(map);

            map.on('error', function(e) {
                console.error('Map error:', e);
            });

            setupSearchAutocomplete();
        }

        function setupSearchAutocomplete() {
            const input = document.getElementById('search-input');
            const suggestionsContainer = document.getElementById('suggestions');

            // Common place types based on Google Places API types
            const placeTypes = [
                { type: 'shopping_mall', keywords: ['shopping mall', 'mall', 'shopping center'] },
                { type: 'supermarket', keywords: ['supermarket', 'grocery store'] },
                { type: 'restaurant', keywords: ['restaurant', 'dining'] },
                { type: 'cafe', keywords: ['cafe', 'coffee shop'] },
                { type: 'bar', keywords: ['bar', 'pub'] },
                { type: 'night_club', keywords: ['night club', 'club'] },
                { type: 'hotel', keywords: ['hotel', 'lodging'] },
                { type: 'school', keywords: ['school'] },
                { type: 'university', keywords: ['university', 'college'] },
                { type: 'hospital', keywords: ['hospital'] },
                { type: 'doctor', keywords: ['doctor', 'physician'] },
                { type: 'pharmacy', keywords: ['pharmacy', 'drugstore'] },
                { type: 'bank', keywords: ['bank'] },
                { type: 'atm', keywords: ['atm', 'cash machine'] },
                { type: 'post_office', keywords: ['post office'] },
                { type: 'police', keywords: ['police station'] },
                { type: 'library', keywords: ['library'] },
                { type: 'park', keywords: ['park'] },
                { type: 'gym', keywords: ['gym', 'fitness center'] },
                { type: 'movie_theater', keywords: ['cinema', 'movie theater'] },
                { type: 'gas_station', keywords: ['gas station', 'petrol station'] },
                { type: 'parking', keywords: ['parking', 'car park'] },
                { type: 'train_station', keywords: ['train station', 'railway station'] },
                { type: 'bus_station', keywords: ['bus station'] },
                { type: 'airport', keywords: ['airport'] }
            ];

            input.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                const query = this.value.toLowerCase();
                
                if (query.length < 2) {
                    suggestionsContainer.style.display = 'none';
                    return;
                }

                searchTimeout = setTimeout(async () => {
                    try {
                        let suggestions = [];

                        // Check if query is in "X in Y" format
                        if (query.includes(' in ')) {
                            const [searchTerm, locationTerm] = query.split(/\s+in\s+/);
                            
                            // If location part is empty or very short, suggest place types
                            if (!locationTerm || locationTerm.length < 2) {
                                suggestions = suggestPlaceTypes(searchTerm, placeTypes);
                            } else {
                                // Get location suggestions from Nominatim
                                suggestions = await getLocationSuggestions(locationTerm, searchTerm);
                            }
                        } else {
                            // If query doesn't contain "in", suggest both place types and "in" completion
                            suggestions = suggestPlaceTypes(query, placeTypes);
                            
                            // Add "in" completion suggestions if the query matches any place type
                            if (suggestions.length > 0) {
                                suggestions.push({
                                    display_name: `${query} in...`,
                                    isPlaceType: true,
                                    isInCompletion: true
                                });
                            }
                            
                            // If no place type matches or query is long enough, add location suggestions
                            if (query.length >= 3) {
                                const locationSuggestions = await getLocationSuggestions(query);
                                suggestions = [...suggestions, ...locationSuggestions];
                            }
                        }

                        displaySuggestions(suggestions, query);
                    } catch (error) {
                        console.error('Error fetching suggestions:', error);
                    }
                }, 300);
            });

            // Hide suggestions when clicking outside
            document.addEventListener('click', function(e) {
                if (!input.contains(e.target) && !suggestionsContainer.contains(e.target)) {
                    suggestionsContainer.style.display = 'none';
                }
            });
        }

        function suggestPlaceTypes(query, placeTypes) {
            const suggestions = [];
            
            placeTypes.forEach(({ type, keywords }) => {
                // Check if query matches the type or any of its keywords
                if (type.includes(query) || keywords.some(k => k.includes(query))) {
                    suggestions.push({
                        display_name: type.charAt(0).toUpperCase() + type.slice(1),
                        isPlaceType: true
                    });
                }
            });

            return suggestions;
        }

        async function getLocationSuggestions(locationTerm, searchTerm = '') {
            let searchParams = new URLSearchParams({
                format: 'json',
                addressdetails: 1,
                limit: 5,
                'accept-language': 'en'
            });

            searchParams.append('q', locationTerm);

            const nominatimUrl = `https://nominatim.openstreetmap.org/search?${searchParams.toString()}`;
            const response = await fetch(nominatimUrl);
            let data = await response.json();

            return data;
        }

        function displaySuggestions(suggestions, originalQuery) {
            const container = document.getElementById('suggestions');
            container.innerHTML = '';

            if (suggestions.length === 0) {
                container.style.display = 'none';
                return;
            }

            suggestions.forEach(place => {
                const div = document.createElement('div');
                div.className = 'suggestion-item';

                if (place.isPlaceType) {
                    // Place type suggestion
                    if (place.isInCompletion) {
                        div.innerHTML = `<div class="suggestion-main">${place.display_name}</div>`;
                    } else {
                        div.innerHTML = `<div class="suggestion-main">${place.display_name} in...</div>`;
                    }
                    div.addEventListener('click', () => {
                        const input = document.getElementById('search-input');
                        input.value = place.isInCompletion ? place.display_name : `${place.display_name} in `;
                        input.focus();
                        container.style.display = 'none';
                    });
                } else {
                    // Location suggestion
                    const mainText = place.display_name.split(',')[0];
                    const secondaryText = place.display_name.split(',').slice(1).join(',').trim();
                    
                    div.innerHTML = `
                        <div class="suggestion-main">${mainText}</div>
                        <div class="suggestion-secondary">${secondaryText}</div>
                    `;

                    div.addEventListener('click', () => {
                        const input = document.getElementById('search-input');
                        const searchPrefix = originalQuery.includes(' in ') ? 
                            originalQuery.split(' in ')[0] + ' in ' : '';
                        input.value = searchPrefix + place.display_name;
                        container.style.display = 'none';
                        searchLocation(place);
                    });
                }

                container.appendChild(div);
            });

            container.style.display = 'block';
        }

        function showError(message) {
            // Clear any existing results first
            const resultsContainer = document.getElementById('results-container');
            const exportContainer = document.getElementById('export-container');
            resultsContainer.innerHTML = '';
            exportContainer.style.display = 'none';

            // Show error message
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function updateResultsList(places) {
            const container = document.getElementById('results-container');
            const exportContainer = document.getElementById('export-container');
            container.innerHTML = '';

            if (places.length > 0) {
                exportContainer.style.display = 'block';
            } else {
                exportContainer.style.display = 'none';
            }

            places.forEach(place => {
                const div = document.createElement('div');
                div.className = 'place-item';
                
                let type = 'Place';
                if (place.tags.amenity) type = place.tags.amenity.replace(/_/g, ' ');
                if (place.tags.tourism) type = place.tags.tourism.replace(/_/g, ' ');
                if (place.tags.shop) type = place.tags.shop.replace(/_/g, ' ');
                type = type.charAt(0).toUpperCase() + type.slice(1);

                div.innerHTML = `
                    <div class="place-name">${place.tags.name || `Unnamed ${type}`}</div>
                    <div class="place-type">${type}</div>
                    <div class="place-details">
                        ${place.tags.cuisine ? `<div>Cuisine: ${place.tags.cuisine}</div>` : ''}
                        ${place.tags.opening_hours ? `<div>Hours: ${place.tags.opening_hours}</div>` : ''}
                        ${place.tags.phone ? `<div>Phone: ${place.tags.phone}</div>` : ''}
                        ${place.tags.addr_street ? `<div>Address: ${place.tags.addr_street}${place.tags.addr_housenumber ? ' ' + place.tags.addr_housenumber : ''}</div>` : ''}
                    </div>
                `;

                div.addEventListener('click', () => {
                    const position = place.type === 'node' ? 
                        [place.lat, place.lon] : 
                        [place.center.lat, place.center.lon];
                    map.setView(position, 18);
                    markers.find(m => m.getLatLng().equals(position))?.openPopup();
                });

                container.appendChild(div);
            });
        }

        async function searchLocation(selectedPlace = null) {
            try {
                let searchQuery = document.getElementById('search-input').value;
                
                if (!searchQuery && !selectedPlace) {
                    showError('Please enter a search query');
                    return;
                }

                // Clear everything at the start of a new search
                clearAllResults();

                // Parse search query
                let searchTerm = '';
                let locationTerm = '';
                
                if (selectedPlace) {
                    locationTerm = selectedPlace.display_name;
                } else if (searchQuery.toLowerCase().includes(' in ')) {
                    const parts = searchQuery.split(/\s+in\s+/i);
                    searchTerm = parts[0].trim();
                    locationTerm = parts[1].trim();
                } else {
                    locationTerm = searchQuery.trim();
                }

                const location = selectedPlace || await getLocation(locationTerm);
                if (!location) {
                    showError('Location not found. Please try a different location.');
                    return;
                }

                const [boundingBox, center] = getBoundingBoxAndCenter(location);
                
                // Draw boundary
                if (boundingBox) {
                    // If GeoJSON boundary is available, use it for more precise boundary
                    if (location.geojson && location.geojson.type === 'Polygon') {
                        const coordinates = location.geojson.coordinates[0].map(coord => [coord[1], coord[0]]);
                        currentBoundary = L.polygon(coordinates, {
                            color: '#FF4444',
                            weight: 2,
                            fillOpacity: 0.1
                        }).addTo(map);
                    } else {
                        // Fallback to rectangle boundary
                        currentBoundary = L.rectangle(boundingBox, {
                            color: '#FF4444',
                            weight: 2,
                            fillOpacity: 0.1
                        }).addTo(map);
                    }

                    // Hide error message if it was showing
                    const errorDiv = document.getElementById('error-message');
                    errorDiv.style.display = 'none';
                }

                // Only search for places if a specific type was requested
                if (searchTerm) {
                    const places = await searchPlaces(searchTerm, center, boundingBox);
                    if (places.length === 0) {
                        showError('No places found in this area. Try a different search.');
                        return;
                    }
                    addMarkers(places);
                    updateResultsList(places);
                }

            } catch (error) {
                console.error('Search error:', error);
                showError('Failed to perform search. Please try again.');
            }
        }

        function clearAllResults() {
            // Clear results list and hide export button
            const resultsContainer = document.getElementById('results-container');
            const exportContainer = document.getElementById('export-container');
            resultsContainer.innerHTML = '';
            exportContainer.style.display = 'none';

            // Clear existing markers
            if (markers) {
                markers.forEach(marker => marker && map.removeLayer(marker));
                markers = [];
            }

            // Clear boundary
            if (currentBoundary) {
                map.removeLayer(currentBoundary);
                currentBoundary = null;
            }

            // Clear error message
            const errorDiv = document.getElementById('error-message');
            errorDiv.style.display = 'none';
            errorDiv.textContent = '';
        }

        async function getLocation(locationTerm) {
            // Special handling for common locations
            let searchTerm = locationTerm;
            if (locationTerm.toLowerCase().includes('newcastle')) {
                searchTerm = 'Newcastle upon Tyne, United Kingdom';
            } else if (locationTerm.toLowerCase().includes('sugar land')) {
                searchTerm = 'Sugar Land, Texas, United States';
            }

            const nominatimUrl = `https://nominatim.openstreetmap.org/search?` + 
                `format=json&` +
                `q=${encodeURIComponent(searchTerm)}&` +
                `addressdetails=1&` +
                `limit=1&` +
                `polygon_geojson=1&` +  // Request GeoJSON boundary
                `accept-language=en`;    // Force English results

            const response = await fetch(nominatimUrl);
            const data = await response.json();
            return data[0];
        }

        function getBoundingBoxAndCenter(location) {
            if (!location) return [null, null];

            let boundingBox;
            const center = {
                lat: parseFloat(location.lat),
                lon: parseFloat(location.lon)
            };

            // Use more precise boundaries for cities and towns
            if (location.type === 'city' || location.type === 'town' || 
                location.type === 'administrative' || location.osm_type === 'relation' ||
                location.class === 'boundary' || location.class === 'place') {
                
                const bbox = location.boundingbox.map(parseFloat);
                boundingBox = [[bbox[0], bbox[2]], [bbox[1], bbox[3]]];
                
                // Adjust zoom level based on bounding box size
                if (map) {
                    const bounds = L.latLngBounds(boundingBox);
                    map.fitBounds(bounds, {
                        padding: [50, 50],
                        maxZoom: 13
                    });
                }
            } else {
                // For other locations, use a reasonable radius
                const radius = 0.05; // roughly 5km
                boundingBox = [
                    [center.lat - radius, center.lon - radius],
                    [center.lat + radius, center.lon + radius]
                ];
                
                // Set view for point locations
                if (map) {
                    map.setView([center.lat, center.lon], 13);
                }
            }

            return [boundingBox, center];
        }

        function getAmenityFilter(searchTerm) {
            if (!searchTerm) return '["shop"~"mall|department_store"]';
            
            const term = searchTerm.toLowerCase();
            
            // Exact matching for specific place types
            if (term.includes('shopping mall') || term.includes('mall')) {
                return '["shop"~"mall|department_store"]';
            }
            if (term.includes('supermarket')) {
                return '["shop"="supermarket"]';
            }
            if (term.includes('restaurant')) {
                return '["amenity"="restaurant"]';
            }
            if (term.includes('cafe')) {
                return '["amenity"="cafe"]';
            }
            if (term.includes('bar') || term.includes('pub')) {
                return '["amenity"~"^(bar|pub)$"]';
            }
            if (term.includes('hotel')) {
                return '["tourism"="hotel"]';
            }
            if (term.includes('school')) {
                return '["amenity"="school"]';
            }
            if (term.includes('university')) {
                return '["amenity"="university"]';
            }
            if (term.includes('hospital')) {
                return '["amenity"="hospital"]';
            }
            if (term.includes('pharmacy')) {
                return '["amenity"="pharmacy"]';
            }
            if (term.includes('bank')) {
                return '["amenity"="bank"]';
            }
            if (term.includes('post office')) {
                return '["amenity"="post_office"]';
            }
            if (term.includes('police')) {
                return '["amenity"="police"]';
            }
            if (term.includes('library')) {
                return '["amenity"="library"]';
            }
            if (term.includes('park')) {
                return '["leisure"="park"]';
            }
            if (term.includes('gym')) {
                return '["leisure"="fitness_centre"]';
            }
            if (term.includes('cinema') || term.includes('movie')) {
                return '["amenity"="cinema"]';
            }
            if (term.includes('gas') || term.includes('petrol') || term === 'fuel' || term === 'petrol_station') {
                return '["amenity"~"^(fuel|charging_station)$"]';
            }
            if (term.includes('parking')) {
                return '["amenity"="parking"]';
            }
            if (term.includes('train station')) {
                return '["railway"="station"]';
            }
            if (term.includes('bus station')) {
                return '["amenity"="bus_station"]';
            }
            if (term.includes('airport')) {
                return '["aeroway"="aerodrome"]';
            }

            // If no exact match, try to match the term exactly against tags
            const cleanTerm = term.replace(/s\b/g, '').replace(/\s+/g, '_');
            return `["amenity"="${cleanTerm}"]|["shop"="${cleanTerm}"]|["tourism"="${cleanTerm}"]|["leisure"="${cleanTerm}"]`;
        }

        async function searchPlaces(searchTerm, center, boundingBox) {
            let amenityFilter = getAmenityFilter(searchTerm);
            
            // Calculate search radius based on bounding box size
            let searchRadius = 2000; // default 2km radius
            if (boundingBox) {
                const latDiff = Math.abs(boundingBox[1][0] - boundingBox[0][0]);
                const lonDiff = Math.abs(boundingBox[1][1] - boundingBox[0][1]);
                // Convert to approximate meters (rough approximation)
                const boxSizeMeters = Math.min(latDiff * 111000, lonDiff * 111000 * Math.cos(center.lat * Math.PI / 180));
                searchRadius = Math.min(Math.max(boxSizeMeters / 2, 500), 5000); // between 500m and 5km
            }
            
            // Add timeout and area size limits for better performance
            const query = boundingBox ?
                `[out:json][timeout:30];
                (
                    node${amenityFilter}(${boundingBox[0][0]},${boundingBox[0][1]},${boundingBox[1][0]},${boundingBox[1][1]});
                    way${amenityFilter}(${boundingBox[0][0]},${boundingBox[0][1]},${boundingBox[1][0]},${boundingBox[1][1]});
                    relation${amenityFilter}(${boundingBox[0][0]},${boundingBox[0][1]},${boundingBox[1][0]},${boundingBox[1][1]});
                );
                out body center qt;
                >;
                out skel qt;` :
                `[out:json][timeout:30];
                (
                    node${amenityFilter}(around:${searchRadius},${center.lat},${center.lon});
                    way${amenityFilter}(around:${searchRadius},${center.lat},${center.lon});
                    relation${amenityFilter}(around:${searchRadius},${center.lat},${center.lon});
                );
                out body center qt;
                >;
                out skel qt;`;

            try {
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: `data=${encodeURIComponent(query)}`
                });
                const data = await response.json();
                
                // Filter and sort results by distance from center
                return data.elements
                    .filter(element => {
                        if (!element.tags) return false;
                        
                        const searchTermLower = searchTerm.toLowerCase();
                        if (searchTermLower.includes('shopping mall') || searchTermLower.includes('mall')) {
                            return element.tags.shop === 'mall' || element.tags.shop === 'department_store';
                        }
                        return true;
                    })
                    .sort((a, b) => {
                        const aLat = a.type === 'node' ? a.lat : a.center.lat;
                        const aLon = a.type === 'node' ? a.lon : a.center.lon;
                        const bLat = b.type === 'node' ? b.lat : b.center.lat;
                        const bLon = b.type === 'node' ? b.lon : b.center.lon;
                        
                        const distA = Math.sqrt(
                            Math.pow(aLat - center.lat, 2) + 
                            Math.pow(aLon - center.lon, 2)
                        );
                        const distB = Math.sqrt(
                            Math.pow(bLat - center.lat, 2) + 
                            Math.pow(bLon - center.lon, 2)
                        );
                        
                        return distA - distB;
                    });
            } catch (error) {
                console.error('Overpass API error:', error);
                throw new Error('Failed to fetch places. Please try again.');
            }
        }

        function addMarkers(places) {
            if (!currentBoundary) return;
            
            const bounds = currentBoundary.getBounds();
            
            places.forEach(place => {
                if ((place.type === 'node' || (place.type === 'way' && place.center)) && place.tags) {
                    const position = place.type === 'node' ? 
                        [place.lat, place.lon] : 
                        [place.center.lat, place.center.lon];

                    // Only add marker if it's within the boundary
                    if (bounds.contains(position)) {
                        let type = 'Place';
                        if (place.tags.amenity) type = place.tags.amenity.replace(/_/g, ' ');
                        if (place.tags.tourism) type = place.tags.tourism.replace(/_/g, ' ');
                        if (place.tags.shop) type = place.tags.shop.replace(/_/g, ' ');
                        type = type.charAt(0).toUpperCase() + type.slice(1);

                        const marker = L.marker(position)
                            .bindPopup(`
                                <strong>${place.tags.name || `Unnamed ${type}`}</strong><br>
                                <em>${type}</em><br>
                                ${place.tags.cuisine ? `Cuisine: ${place.tags.cuisine}<br>` : ''}
                                ${place.tags.opening_hours ? `Hours: ${place.tags.opening_hours}<br>` : ''}
                                ${place.tags.phone ? `Phone: ${place.tags.phone}<br>` : ''}
                                ${place.tags.website ? `<a href="${place.tags.website}" target="_blank">Website</a><br>` : ''}
                                ${place.tags.addr_street ? `Address: ${place.tags.addr_street}${place.tags.addr_housenumber ? ' ' + place.tags.addr_housenumber : ''}<br>` : ''}
                            `)
                            .addTo(map);
                        markers.push(marker);
                    }
                }
            });
        }

        function exportResults() {
            const container = document.getElementById('results-container');
            const places = Array.from(container.getElementsByClassName('place-item')).map(item => {
                const name = item.querySelector('.place-name').textContent;
                const type = item.querySelector('.place-type').textContent;
                const details = Array.from(item.querySelector('.place-details').children)
                    .map(div => div.textContent)
                    .join('\n');
                return `${name}\n${type}\n${details}\n-------------------`;
            }).join('\n\n');

            const blob = new Blob([places], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'search_results.txt';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        async function searchCategory(category) {
            const input = document.getElementById('search-input');
            const currentLocation = input.value.split(' in ')[1];
            
            if (!currentLocation && !currentBoundary) {
                showError('Please enter a location first');
                return;
            }

            // Clear error message at the start of new search
            clearError();

            // If we have a current boundary, search within it
            if (currentBoundary) {
                const bounds = currentBoundary.getBounds();
                const center = bounds.getCenter();
                
                try {
                    // Adjust category for gas stations
                    const searchTerm = category === 'fuel' ? 'petrol_station' : category;
                    
                    const places = await searchPlaces(searchTerm, 
                        { lat: center.lat, lon: center.lng }, 
                        [[bounds.getSouth(), bounds.getWest()], 
                         [bounds.getNorth(), bounds.getEast()]]);
                    
                    // Filter places to ensure they're within the boundary
                    const filteredPlaces = places.filter(place => {
                        const placeLat = place.type === 'node' ? place.lat : place.center.lat;
                        const placeLon = place.type === 'node' ? place.lon : place.center.lon;
                        return bounds.contains([placeLat, placeLon]);
                    });

                    if (filteredPlaces.length === 0) {
                        showError(`No ${category.replace('_', ' ')} found in this area`);
                        return;
                    }

                    // Clear existing markers but keep the boundary
                    if (markers) {
                        markers.forEach(marker => marker && map.removeLayer(marker));
                        markers = [];
                    }

                    addMarkers(filteredPlaces);
                    updateResultsList(filteredPlaces);
                } catch (error) {
                    console.error('Category search error:', error);
                    showError('Failed to search for places. Please try again.');
                }
            } else {
                // If no boundary, perform a new search with the category
                input.value = `${category} in ${currentLocation}`;
                searchLocation();
            }
        }

        // Add a separate function to clear error message
        function clearError() {
            const errorDiv = document.getElementById('error-message');
            errorDiv.style.display = 'none';
            errorDiv.textContent = '';
        }

        // Initialize the map when the page loads
        document.addEventListener('DOMContentLoaded', initMap);

        // Add enter key support for search
        document.getElementById('search-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchLocation();
            }
        });
    </script>
</body>
</html> 